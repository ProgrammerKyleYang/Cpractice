 ///
 /// @file    Point.cc
 /// @author  kyle(kyleyang58@gmail.com)
 /// @date    2019-01-08 23:00:41
 ///
 
#include <iostream>
using std::cout;
using std::endl;
class Point//因为当类中没有显示定义构造函数的时候，编译器会自动提供一个默认（无参）构造函数
{		//在显示定义了构造函数之后，系统就不会再自动提供默认的构造函数了；
	public://构造函数的作用就是用来构造数据成员的
	Point ()//此Point（）为无参构造函数
	: _ix(0)//这才是真正的初始化，初始化列表（表达式）
	, _iy(0)//有了这个初值，后面的就可以不用了
			//初始化中数据成员的数据，顺序只与数据成员在被声明时的顺序有关
	{
		cout << "已经调用默认构造函数！"<<endl;
	//	_ix = 0;//赋值语句  最好在函数体外部定义
	//	_iy = 0;//赋值前已经存在
	}

	Point(int ix, int iy)//显示定义的构造函数后，系统就不会提供默认构造函数，
						//此时若还要调用默认构造函数（无参构造函数）就必须显示提供一个
						//构造函数支持函数重载
	{
		_ix = ix ;
		_iy = iy ;
		cout << "Point(int,int)" << endl;//point标记法，要是执行了上面两个语句则打印这一行
	}

	void print()
	{
		cout << "(" << _ix
			 << "," << _iy
			 << ")" << endl;
	}

	~Point()//析构函数只有一个，是无参的，特点是有个~号，在销毁时调用
			//析构函数是被自动调用的，位于栈区
			//pt1,pt2都位于栈区，在调用结束之后都要被销毁
			//
	{
		cout << "已调用析构函数" << endl;
	}
	//系统提供的析构函数就是什么都没有的
	//需要我们自己设置析构函数的情况在demo文件夹文件中


	private:
		int _ix;
		int _iy;

};


int test0(void)
{
	int a(70);//与第14、15行作用类似，都是初始化
	cout << "a = "<< a << endl;
	Point pt1;//这里是可以调用构造函数的（无参且未初始化）并且可以通过编译。但是结果是乱码，因为还没初始化
	//因为当类中没有显示定义构造函数的时候，编译器会自动提供一个默认（无参）构造函数
	//Point pt2(1,2);//此时运行时出错，还未定义
	pt1.print();
	Point pt2(1,2);
					//当栈对象被销毁时会自动调用析构函数
					//析构函数的作用是执行清理操作
	pt2.print();
//	pt1.~Point();//显示调用析构函数,一般不主动调用
	return 0;
}

int main()
{
cout << "即将进入到test0"<<endl;
test0();
cout << "已经退出了test0"<<endl;
return 0;
}




